{
  "_from": "express-openapi",
  "_id": "express-openapi@4.5.0",
  "_inBundle": false,
  "_integrity": "sha512-wu7FR51vuGcRhPT6pM0jk22+aychAIA96XRnjCOnnsSGit9MzaaI75A04eNrMOXC6Q2IpGlYBKPouyUT7wm5CA==",
  "_location": "/express-openapi",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "express-openapi",
    "fetchSpec": "latest",
    "name": "express-openapi",
    "raw": "express-openapi",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/express-openapi/-/express-openapi-4.5.0.tgz",
  "_shasum": "c563f6f398c5d676a05e7836e7dff0a97ff45837",
  "_spec": "express-openapi",
  "_where": "/home/scadmin/projects/tbx2rdf/server",
  "author": {
    "name": "Joseph Spencer"
  },
  "bugs": {
    "url": "https://github.com/kogosoftwarellc/open-api/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+label%3Aexpress-openapi"
  },
  "bundleDependencies": false,
  "dependencies": {
    "express-normalize-query-params-middleware": "^0.5.0",
    "openapi-framework": "0.23.0",
    "openapi-types": "1.3.4"
  },
  "deprecated": false,
  "description": "An unopinionated OpenAPI framework for express",
  "devDependencies": {
    "@types/ajv": "^1.0.0",
    "@types/express": "^4.16.0",
    "multer": "^1.4.1"
  },
  "files": [
    "dist/**/*"
  ],
  "homepage": "https://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi#readme",
  "keywords": [
    "express",
    "openapi",
    "swagger"
  ],
  "license": "MIT",
  "main": "./dist/index.js",
  "name": "express-openapi",
  "optionalDependencies": {},
  "readme": "# express-openapi [![NPM version][npm-image]][npm-url] [![Downloads][downloads-image]][npm-url] [![Build Status][travis-image]][travis-url] [![Coveralls Status][coveralls-image]][coveralls-url] [![Gitter chat][gitter-image]][gitter-url]\n> An unopinionated OpenAPI framework for express\n\n## Highlights\n\n* Supported versions:\n  * OpenAPI 2.0 (f.k.a. swagger 2.0)\n  * OpenAPI 3.0 (beta until the official JSONSchema is released https://github.com/OAI/OpenAPI-Specification/issues/1301)\n* Performant.\n* Extensively tested.\n* Unobtrusively opinionated.\n* Stays as close to `express` as possible.\n* Write API documentation in JSON or Yaml\n  * See [args.apiDoc](#argsapidoc)\n* Supports Promise based middleware and response handlers.\n  * See [args.promiseMode](#argspromisemode)\n* Supports Security Filtering\n  * See [args.securityFilter](#argssecurityfilter)\n* Leverages openapi parameter lists for parameter defaults, type coercion,\nand validation.\n  * See [openapi-default-setter](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-default-setter)\n  * See [openapi-request-coercer](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-request-coercer)\n  * See [openapi-request-validator](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-request-validator)\n* Leverages OpenAPI response definitions to provide `res.validateResponse` tailored to a particular route.\n  * See [openapi-response-validator](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-response-validator)\n* Leverages security definitions for security management.\n  * See [openapi-security-handler](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-security-handler)\n* Validates api documents.\n  * See [openapi-schema-validator](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-schema-validator)\n* Supports schema extension.\n  * See [Extending OpenAPI Schema](#extending-openapi-schema)\n* Configurable Middleware.\n  * See [Configuring Middleware](#configuring-middleware)\n* Supports custom `format` validators.\n  * See [args.customFormats](#argscustomformats)\n* Supports `collectionFormat` for `formData` `array` parameters.\n* Conforms to the [single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle).\n* Clean interface.\n* Supports error middleware scoped to your API's `basePath`.\n  * See [args.errorMiddleware](#argserrormiddleware)\n* Adds a route for Swagger UI (`apiDoc.basePath` + `args.docsPath`).\n* Adds operation tags to your apiDoc.tags array and sorts them alphabetically for you.\n  * See how it's done in the [basic-usage](\nhttps://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi/test/sample-projects/basic-usage/api-doc.js#L37)\n    sample project.\n* Supports TypeScript\n  * See [Using with TypeScript](#using-with-typescript)\n* Supports external schema references\n  * See [args.externalSchemas](#argsexternalschemas)\n* Client SDK generators available.\n  * See [fetch-openapi](https://github.com/kogosoftwarellc/open-api/tree/master/packages/fetch-openapi).\n* Adds `apiDoc` and `operationDoc` to requests E.G. `req.apiDoc` and `req.operationDoc`\n* Handles request payloads with `consumes` mimeTypes.\n  * See [args.consumesMiddleware](#argsconsumesmiddleware)\n* Supports matching paths by regex to set `security` in `operation` docs.\n  * See [args.pathSecurity](#argspathsecurity)\n\n## Table of Contents\n\n* [What is OpenAPI](#what-is-openapi)\n* [Getting Started](#getting-started)\n* [Vendor Extensions](#vendor-extensions)\n  * [Operation parameters](#operation-parameters)\n  * [Configuring Middleware](#configuring-middleware)\n* [API](#api)\n  * [initialize(args)](#initializeargs)\n    * [args.apiDoc](#argsapidoc)\n    * [args.app](#argsapp)\n    * [args.consumesMiddleware](#argsconsumesmiddleware)\n    * [args.customFormats](#argscustomformats)\n    * [args.dependencies](#argsdependencies)\n    * [args.docsPath](#argsdocspath)\n    * [args.enableObjectCoercion](#argsenableobjectcoercion)\n    * [args.errorMiddleware](#argserrormiddleware)\n    * [args.errorTransformer](#argserrortransformer)\n    * [args.exposeApiDocs](#argsexposeapidocs)\n    * [args.externalSchemas](#argsexternalschemas)\n    * [args.operations](#argsoperations)\n    * [args.pathSecurity](#argspathsecurity)\n    * [args.paths](#argspaths)\n    * [args.pathsIgnore](#argspathsignore)\n    * [args.promiseMode](#argspromisemode)\n    * [args.routesGlob](#argsroutesglob)\n    * [args.routesIndexFileRegExp](#argsroutesindexfileregexp)\n    * [args.securityHandlers](#argssecurityhandlers)\n    * [args.validateApiDoc](#argsvalidateapidoc)\n* [Using with TypeScript](#using-with-typescript)\n  * [Prerequisites](#prerequisites)\n  * [TypeScript Example](#typescript-example)\n* [Supported Versions of Node](#supported-version-of-node)\n* [License](#license)\n\n## What is OpenAPI?\n\nTaken from [openapis.org](https://openapis.org/specification):\n\n> The goal of the OAI specification is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming\n\nTo study the current specification [view the docs](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md).\n\n## Getting Started\n\n*To see example projects, look at our [test suite](https://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi/test/sample-projects).*\n\nThis getting started guide will use the most fundamental concepts of OpenAPI and\n`express-openapi`.\n\n1. Create your API's main apiDoc.  You can create it anywhere.  For this example\n   we'll create it in under an `api-v1/` directory:\n\n    ```javascript\n    // ./api-v1/api-doc.js\n\n    const apiDoc = {\n      swagger: '2.0',\n      basePath: '/v1',\n      info: {\n        title: 'A getting started API.',\n        version: '1.0.0'\n      },\n      definitions: {\n        World: {\n          type: 'object',\n          properties: {\n            name: {\n              description: 'The name of this world.',\n              type: 'string'\n            }\n          },\n          required: ['name']\n        }\n      },\n      paths: {}\n    };\n\n    export default apiDoc;\n    ```\n\n    You may be wondering why `paths` can be an empty object literal.  We'll get to that in a second.\n\n    This is all that is required for our API's main apiDoc.  To see the full list of values\n    and options for the main apiDoc you can view [The Schema](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schema).\n\n    **Note:** You can also use a YAML string instead of javascript objects e.g.\n\n    ```yaml\n    # ./api-v1/api-doc.yml\n    swagger: '2.0'\n    basePath: '/v1'\n    info:\n      title: 'A getting started API.'\n      version: '1.0.0'\n    definitions:\n      World:\n        type: 'object'\n        properties:\n          name:\n            description: 'The name of this world.'\n            type: 'string'\n        required:\n          - 'name'\n    paths: {}\n    ```\n\n1. Create path handlers.\n\n    Our `paths` object was empty in the main apiDoc because `express-openapi` will generate it for us\n    based on the location of our path handlers.\n    For this example we'll place our path handlers under `api-v1/paths/`.\n\n    Let's create a `worlds` path:\n\n    ```javascript\n    // ./api-v1/paths/worlds.js\n    export default function(worldsService) {\n      let operations = {\n        GET\n      };\n\n      function GET(req, res, next) {\n        res.status(200).json(worldsService.getWorlds(req.query.worldName));\n      }\n\n      // NOTE: We could also use a YAML string here.\n      GET.apiDoc = {\n        summary: 'Returns worlds by name.',\n        operationId: 'getWorlds',\n        parameters: [\n          {\n            in: 'query',\n            name: 'worldName',\n            required: true,\n            type: 'string'\n          }\n        ],\n        responses: {\n          200: {\n            description: 'A list of worlds that match the requested name.',\n            schema: {\n              type: 'array',\n              items: {\n                $ref: '#/definitions/World'\n              }\n            }\n          },\n          default: {\n            description: 'An error occurred',\n            schema: {\n              additionalProperties: true\n            }\n          }\n        }\n      };\n\n      return operations;\n    }\n    ```\n\n    In OpenAPI we define what operations a path exposes.  Operations are exposed as HTTP\n    methods.\n\n    The `apiDoc` property of the `GET` http method configures the `getWorld` operation\n    with `express-openapi`.  Without it `express-openapi` would do nothing with it.  We\n    can see that `worldName` is a required query parameter.  If we were to call this\n    operation without `worldName` we would receive a 400 input validation error.\n\n    In this example, we're also using dependency injection.  This allows us to easily\n    connect our path handlers with our API's services.  We could've exposed an object\n    literal instead of a function.  The dependency injection approach is recommended\n    which is why we use it here.\n\n    **Note:** If you prefer not to follow this design driven approach, or if you'd\n    rather have your API's documentation solely in the apiDoc file, you can provide\n    operation handlers with [args.operations](#argsoperations).\n\n1. Create services\n\n    We referenced a `worldsService` in our path handler, let's create it now.  It's\n    best to place services that conform to your API's object definitions under a versioned\n    folder.  This keeps API versioned code separately and allows you to scale your app\n    for multiple API versions.\n\n    ```javascript\n    // ./api-v1/services/worldsService.js\n\n    let worlds = {\n      Earth: {\n        name: 'Earth'\n      }\n    };\n\n    const worldsService = {\n      getWorlds(name) {\n        return worlds[name] ? [worlds[name]] : [];\n      }\n    };\n\n    export default worldsService;\n    ```\n\n1. Initialize your `express` app with `express-openapi`\n\n    We'll create our app file as usual and we'll initialize it with `express-openapi`:\n\n    ```javascript\n    // ./app.js\n    import express from 'express';\n    import { initialize } from 'express-openapi';\n    import v1WorldsService from './api-v1/services/worldsService';\n    import v1ApiDoc from './api-v1/api-doc';\n\n    const app = express();\n    initialize({\n      app,\n      // NOTE: If using yaml you can provide a path relative to process.cwd() e.g.\n      // apiDoc: './api-v1/api-doc.yml',\n      apiDoc: v1ApiDoc,\n      dependencies: {\n        worldsService: v1WorldsService\n      },\n      paths: './api-v1/paths'\n    });\n\n    app.listen(3000);\n    ```\nOur paths are now active and we can test them out with [Swagger UI](http://petstore.swagger.io/).  This getting started guide\ndidn't cover everything.  For more examples see the [sample projects](https://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi/test/sample-projects) used in our\nextensive test suite.\n\n## Vendor extensions\n\nOpenAPI allows vendor extensions to be used throughout your api doc.\n\n### Operation parameters\n\n* `'x-express-openapi-case-sensitive': false` - Use this in parameter definitions to\n  allow parameter names to be case insensitive.  Use cases may include moving from\n  a legacy application that didn't enforce case sensitivity (see #49).\n\n  ```javascript\n  GET.apiDoc = {\n    ...\n    parameters: [\n      {\n        name: 'paramName',\n        in: 'query',\n        type: 'string',\n        required: true,\n        'x-express-openapi-case-sensitive': false\n      }\n    ],\n    ...\n  };\n  ```\n\n  Calling this operation with `paramname=5` will not affect the validity of the request\n  and your path handler will receive `paramName=5`.\n\n### Extending OpenAPI Schema\n\n* `x-express-openapi-schema-extension: {}` - Use this to extend the schema being used.  An\n  example use case can be allowing `oneOf` with version 2.0 documents.\n\n  i.e.\n\n  ```\n  x-express-openapi-schema-extension: {\n    definitions: {\n      schema: {\n        properties: {\n          oneOf: {\n            type: \"array\",\n            minItems: 1,\n            items: {\n              $ref: \"#/definitions/schema\"\n            }\n          }\n        }\n      }\n    }\n  }\n  ```\n\n### Configuring Middleware\n\nYou can directly control what middleware `express-openapi` adds to your express app\nby using the following vendor extension properties.  These properties are scoped, so\nif you use one as a root property of your API Document, all paths and operations will\nbe affected.  Similarly if you just want to configure middleware for an operation,\nyou can use these properties in said operation's apiDoc.  See full examples in the\n[./test/sample-projects/](\nhttps://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi/test/sample-projects)\ndirectory.\n\n\n* `'x-express-openapi-additional-middleware': [myMiddleware]` - Adds the provided\nmiddleware _after_ defaults, coercion, and validation middleware (added by\n`express-openapi`) but _before_ middleware defined in operations and _before_ the response is sent.  This property\ninherits from all previous properties. For an example of how to perform global response validation based on this extension, see [Express Middleware to Validate Responses on All Routes](#express-middleware-to-validate-responses-on-all-routes)\n* `'x-express-openapi-inherit-additional-middleware': false` - Prevents middleware\nadded in a parent scope with `x-express-openapi-additional-middleware`.  This extension\nworks from the methodDoc up to the apiDoc, as opposed to the apiDoc down to the methodDoc.\nThe effect is that using this extension in the methodDoc would prevent that method\nfrom receiving any additional middleware defined in parent scopes.  You can use this\nextension in any scope (methodDoc, pathDoc, or apiDoc) and the result i the same.\n* `'x-express-openapi-disable-middleware': true` - Disables all middleware.\n* `'x-express-openapi-disable-coercion-middleware': true` - Disables coercion middleware.\n* `'x-express-openapi-disable-defaults-middleware': true` - Disables\ndefaults middleware.\n* `'x-express-openapi-disable-response-validation-middleware': true` - Disables\nresponse validation middleware I.E. no `res.validateResponse` method will be\navailable in the affected operation handler method.\n* `'x-express-openapi-disable-validation-middleware': true` - Disables input\nvalidation middleware.\n\n#### Express Middleware to Validate Responses on All Routes\n\nBy overriding the implementation of `res.send` within a middleware function, it is possible to perform `res.validateResponse` on all paths, and allow the paths to use `res.send` or `res.json`. The example below is how such a middleware might be added to `app.js`.\n\n```javascript\nfunction validateAllResponses(req, res, next) {\n    const strictValidation = req.apiDoc['x-express-openapi-validation-strict'] ? true : false;\n    if (typeof res.validateResponse === 'function') {\n        const send = res.send;\n        res.send = function expressOpenAPISend(...args) {\n          const onlyWarn = !strictValidation;\n          if (res.get('x-express-openapi-validation-error-for') !== undefined) {\n              return send.apply(res, args);\n          }\n          const body = args[0];\n          let validation = res.validateResponse(res.statusCode, body);\n          let validationMessage;\n          if (validation === undefined) {\n              validation = { message: undefined, errors: undefined };\n          }\n          if (validation.errors) {\n              const errorList = Array.from(validation.errors).map(_ => _.message).join(',');\n              validationMessage = `Invalid response for status code ${res.statusCode}: ${errorList}`;\n              console.warn(validationMessage);\n              // Set to avoid a loop, and to provide the original status code\n              res.set('x-express-openapi-validation-error-for', res.statusCode.toString());\n          }\n          if (onlyWarn || !validation.errors) {\n              return send.apply(res, args);\n          } else {\n              res.status(500);\n              return res.json({ error: validationMessage });\n          }\n      }\n    }\n    next();\n}\n\ninitialize({\n    app: app,\n    paths: path.resolve(__dirname, 'api-paths'),\n    'x-express-openapi-additional-middleware': [validateAllResponses],\n    'x-express-openapi-validation-strict': true,\n    apiDoc: apiDoc\n});\n```\n\n\n## API\n\n### initialize(args)\n\nInitializes paths and middleware on an express app, and returns an initialized\napi.  An initialized api contains the following properties:\n\n* `apiDoc` - This is the final result of the apiDoc after processing.\n\n#### args.apiDoc\n\n|Type|Required|Description|\n|----|--------|-----------|\n|Object or String|Y|This is an OpenAPI (swagger 2.0) compliant document.  See the [OpenAPI-Specification](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md) for more details.|\n\n`args.apiDoc.paths` can be an empty object. In that case `express-openapi` will populate this\nfor you based on your operation level apiDocs.\nIt is also possible to have just [one central apiDoc](https://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi/test/sample-projects/basic-usage-with-central-apiDoc).\n\n`args.apiDoc.basePath` will add a prefix to all paths added by `express-openapi`.\n\n`args.apiDoc.definitions` will be used for de-referencing `$ref` properties in\nparameters.\n\nYou may pass a javascript object or a YAML string.\n\n#### args.app\n\n|Type|Required|Description|\n|----|--------|-----------|\n|Object|Y|The express app you wish to initialize.|\n\n#### args.consumesMiddleware\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Object|N|null|A key value map of mimeTypes and middleware.|\n\nEach key is the mime type from the consumes array of either the apiDoc or the operation doc.\n\n```javascript\nvar bodyParser = require('body-parser');\ninitialize({\n  /*...*/\n  consumesMiddleware: {\n    'application/json': bodyParser.json(),\n    'text/text': bodyParser.text()\n  }\n  /*...*/\n});\n```\n\nBy adding a middleware handler for 'multipart/form-data' file uploads can be processed. For example, using [multer](https://github.com/expressjs/multer):\n\n```javascript\nvar multer = require('multer');\ninitialize({\n  /*...*/\n  consumesMiddleware: {\n    'multipart/form-data': function(req, res, next) {\n      multer().any()(req, res, function(err) {\n        if (err) return next(err);\n        req.files.forEach(function(f) {\n          req.body[f.fieldname] = ''; // Set to empty string to satisfy OpenAPI spec validation\n        });\n        return next();\n      });\n    }\n  }\n  /*...*/\n});\n```\n\nNow you can access your non-file fields via `req.body`, and your files via `req.files`. See a full example in the [with-consumes-middleware-multipart-openapi3](\nhttps://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi/test/sample-projects/with-consumes-middleware-multipart-openapi3) test.\n\n#### args.customFormats\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Object|N|null|An object of custom formats.|\n\nEach key is the name of the format to be used with the `format` keyword.  Each value\nis a function that accepts an input and returns a boolean value.\n\n```javascript\ninitialize({\n  /*...*/\n  customFormats: {\n    myFormat: function(input) {\n      return input === 'foo';\n    }\n  }\n  /*...*/\n});\n```\n\nSee Custom Formats in [jsonschema](https://github.com/tdegrunt/jsonschema#custom-formats).\n\n#### args.dependencies\n\n|Type|Required|Description|\n|----|--------|-----------|\n|Object|N|Mapping from keys to dependency objects that can be injected as named parameters into path handlers exported as functions |\n\nFor path handlers that export a function instead of an object.  The parameter names of the exported function directly map to keys listed in this object.\n\nExample\n```javascript\n// ├── api-doc.js\n// ├── api-paths1\n// │   └── users.js\n// ├── api-paths2\n// │   └── location.js\n// └── app.js\n\n// app.js\n// create some backend services. You can use typescript.\n\n// a mock data provider, for testing or local development\nvar mockDataProvider = require(\"custom-mock-data-provider\");\n\n// a pretend geo service, as an example of allowing route handlers to perform external interactions\nvar geoService = require(\"awesome-geo-service\")({url: \"http.example.com/geoservice\"});\n\ninitialize({\n    apiDoc: require('./api-doc.js'),\n    app: app,\n    paths: [\n        path.resolve(__dirname, 'api-paths'),\n    ],\n\n    // Provide a mapping of dependency names.\n    // The keys of this object can be named parameters in the signature of\n    // the functions exported from the modules in your paths directory.\n    dependencies: {\n        dataprovider: mockDataProvider(),\n        geoservice: geoService\n    }\n});\n\n// api-paths1/users.js\n// inject both a dataprovider and geoservice dependency.\nmodule.exports = function(geoservice, dataprovider) {\n    var doc = {\n        GET: function (req, res, next) {\n            res.json({user: dataprovider.getUser(req.params.userid), location: geoservice.getUserLocation(req.params.userid)});\n        }\n    };\n    doc.GET.apiDoc = {\n        ...\n    };\n    return doc;\n};\n\n\n// api-paths2/location.js\n// only inject a geoservice dependency.\nmodule.exports = function(geoservice) {\n    var doc = {\n        GET: function (req, res, next) {\n            res.json({location: geoservice.getUserLocation(req.session.user.id)});\n        }\n    };\n    doc.GET.apiDoc = {\n        ...\n    };\n    return doc;\n};\n```\n\n#### args.docsPath\n\n|Type|Required|Default Value|Description|\n|----|--------|-----------|----|\n|String|N|/api&#8209;docs|Sets the path that Swagger UI will use to request `args.apiDoc` with populated paths.  You can use this to support multiple versions of your app.|\n\n#### args.enableObjectCoercion\n\n|Type|Required|Default Value|Description|\n|----|--------|-----------|----|\n|Boolean|N|false|Enables object coercion in requests.|\n\nSee [openapi-request-coercer](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-request-coercer)\n\n#### args.errorMiddleware\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Object|N|null|A middleware function that is scoped to your api's basePath.|\n\nThis is just standard express error middleware (I.E. it has 4 arguments `err, req, res, next`).\nWhen an error occurs in your API's handlers, it'll be passed to this middleware.  The\nrest of your app is unaffected.\n\n**Note:** 4 arguments (no more, no less) must be defined in your errorMiddleware function. Otherwise the function will be silently ignored.\n\n```javascript\ninitialize({\n  apiDoc: require('v3-api-doc'),\n  /*...*/\n  errorMiddleware: function(err, req, res, next) { // only handles errors for /v3/*\n      /* do something with err in a v3 way */\n  }\n  /*...*/\n});\n```\n\n#### args.errorTransformer\n\n|Type|Required|Description|\n|----|--------|-----------|\n|Function|N|Transforms errors to a standard format as defined by the application.  See [openapi-request-validator#args.errorTransformer](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-request-validator#argserrortransformer) and [openapi-response-validator](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-response-validator) for more info.|\n\n#### args.exposeApiDocs\n\n|Type|Required|Default Value|Description|\n|----|--------|-----------|-------|\n|Boolean|N|true|Adds a route at `args.apiDoc.basePath` + `args.docsPath`.  The route will respond with `args.apiDoc`.|\n\n#### args.externalSchemas\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Object|N|null|Map id to pre-loaded external schema|\n\nThis is used to resolve a schema reference `$ref`. Id can be a URL or relative path from `args.docPath`.\n\n```javascript\ninitialize({\n  apiDoc: require('v3-api-doc'),\n  /*...*/\n  externalSchemas: {\n    'http://example.com/schema': {\n      description: \"example schema\",\n      type: object,\n      /*....*/\n    },\n    'http://example.com/another-schema': {\n      /*....*/\n    }\n  }\n  /*...*/\n});\n```\n\nAnd then you can reference them in your api-doc file and route handlers.\n```javascript\n{\n  /*...*/\n  parameters: {\n    foo: {\n      \"in\": \"body\",\n      name: \"foo\",\n      schema: { $ref: 'http://example.com/schema'}\n    }\n  },\n  /*...*/\n  definitions: {\n   bar: { $ref: 'http://example.com/another-schema#/definitions/bar'}\n  }\n}\n```\nor\n```javascript\nput.apiDoc = {\n  /*...*/\n  parameters: [\n    {\n      \"in\": \"body\",\n      name: \"foo\",\n      schema: { $ref: 'http://example.com/schema'}\n    }\n  ],\n /*...*/\n}\n```\n#### args.operations\n\n|Type|Required|Description|\n|----|--------|-----------|\n|Object|Y (unless args.paths is provided)|An Object whose keys are operationIds in your apiDoc and whose values are operation handlers (functions)|\n\nConsider the following example:\n\n```yml\n# ./apiDoc.yml\nswagger: '2.0'\ninfo:\n  title: sample api doc\n  version: '3'\npaths:\n  /foo:\n    get:\n      operationId: getFoo\n      responses:\n        default:\n          description: return foo\n          schema: {}\n```\n\n```js\n// ./app.js\nimport express from 'express';\nimport { initialize } from 'express-openapi';\n\nconst app = express();\n\ninitialize({\n  app,\n  apiDoc: './apiDoc.yml',\n  operations: {\n    getFoo: function(req, res) {\n      res.send('foo');\n    }\n  }\n});\n\napp.listen(3000);\n```\n\nOperations also get `args.dependencies` injected as\n`this.dependencies` on the function scope. This requires your\noperations to be regular [function\nexpressions](https://developer.mozilla.org/en-US/docs/web/JavaScript/Reference/Operators/function)\nand not [arrow\nfunctions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n(due to the fact that `this` is lexical to the surrounding scope in an\narrow function and cannot be bound to anything else). x\n\n```js\n// ./app.js\nimport express from 'express';\nimport { initialize } from 'express-openapi';\n\nconst app = express();\n\ninitialize({\n  app,\n  apiDoc: './apiDoc.yml',\n  dependencies: {\n    log: console.log\n  },\n  operations: {\n    getFoo: function(req, res) {\n      this.dependencies.log('calling request handler');\n      res.send('foo');\n    }\n  }\n});\n\napp.listen(3000);\n```\n\n#### args.pathSecurity\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Array|N|null|An array of tuples.|\n\nEach tuple in the array consists of a `RegExp` to match paths, and a `security`\ndefinition (see [security](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operation-object)).  The tuples are traversed in reverse order, so the bottom\nmost matching `RegExp` wins.  When a matching definition is found and the operation\nhad no `security` defined, it is added to the `operationDoc` and security middleware\nis applied.\n\n```javascript\ninitialize({\n  apiDoc: require('v3-api-doc'),\n  /*...*/\n  pathSecurity: [\n    // here /some/{pathId} will get theirSecurity.\n    [/^\\/some/\\{pathId\\}/, [{mySecurity:[]}]],\n    [/^\\/some/\\{pathId\\}/, [{theirSecurity:[]}]]\n  ]\n  /*...*/\n});\n```\n\n#### args.paths\n\n|Type|Required|Description|\n|----|--------|-----------|\n|String or Array|Y (unless args.operations is provided)|Relative path or paths to the directory or directories that contain your route files or route specifications.|\n\n\nPath files are logically structured according to their URL path.  For cross platform\ncompatibility, URLs that accept a parameter use the swagger format for parameters\nas opposed to the express format (i.e. use `{id}` instead of `:id`).  Filenames in\nWindows do not allow the `:` character as it is confused with drive names.\n\nFor example, if you have the following api paths that you wish to add to your express\napp:\n\n```\nGET /v1/users/{id}\nPOST /v1/users\n```\n\nYou would define `basePath: '/v1'` in your `apiDoc`, and layout your `paths` directory\nas follows:\n\n```\n<project>\n        `paths/\n               `users/\n                     `{id}.js\n                users.js\n```\n\nThe contents of `<project>/paths/users/{id}.js` would look like this:\n\n```javascript\nmodule.exports = {\n  // parameters for all operations in this path\n  parameters: [\n    {\n      in: 'path',\n      name: 'id',\n      required: true,\n      type: 'integer'\n    }\n  ],\n\n  /*\n    Also available are:\n    GET\n    DELETE\n    PATCH\n    OPTIONS\n    del\n    delete\n    patch...\n    see index.js for the full list.\n  */\n\n  get: [\n    /* business middleware not expressible by OpenAPI documentation goes here */\n    function(req, res, next) {\n      var validationError = res.validateResponse(200, /* return the user or an error */);\n\n      if (validationError)\n        return next(validationError);\n      }\n\n      res.status(200).json(/* return the user or an error */);\n    }\n  ],\n\n  post: post\n};\n\nmodule.exports.get.apiDoc = {\n  description: 'A description for retrieving a user.',\n  tags: ['users'],\n  operationId: 'getUser',\n  // parameters for this operation\n  parameters: [\n    {\n      in: 'query',\n      name: 'firstName',\n      type: 'string'\n    }\n  ],\n  responses: {\n    default: {\n      $ref: '#/definitions/Error'\n    }\n  }\n};\n\nfunction post(req, res, next) {\n  /* ... */\n}\n\npost.apiDoc = {\n  /* ... */\n};\n\n```\n\nAlternatively, args.paths may contain route specifications of the form\n`{ path: '/foo/{id}', module: require('./handlers/foo') }`.\n\nModules under `args.paths` expose methods.  Methods may either be a method handler\nfunction, or an array of business specific middleware + a method handler function.\n\n`express-openapi` will prepend middleware to this stack based on the parameters\ndefined in the method's `apiDoc` property.  If no `apidoc` property exists on the\nmodule method, then `express-openapi` will add no additional middleware.\n\n**Note:** Handlers in args.operations will override handlers in args.paths\n\n#### args.pathsIgnore\n\n|Type|Required|Description|\n|----|--------|-----------|\n|RegExp|N|Paths matching this regular expression will be ignored.|\n\nA common use for this is to ignore spec or test files located in the same folder than the paths, like:\n\n```javascript\ninitialize({\n  apiDoc: apiDoc,\n  app: app,\n  paths: './api-v1/paths',\n  pathsIgnore: new RegExp('\\.(spec|test)$')\n})\n```\n\n#### args.promiseMode\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Boolean|N|false|Allows middleware and path handlers to return promises.|\n\nThe following would then be supported:\n\n```\nexport default function(worldsService) {\n  const operations = {\n    GET,\n    PUT,\n  };\n\n  // If using node >= 7.6 you can use async/await.\n  async function GET(req, res) {\n    const worlds = await worldsService.getWorlds(req.query.worldName);\n    if (!worlds.length) {\n      throw {\n        status: 404,\n        message: 'No worlds were found',\n      };\n    }\n    res.status(200).json(worlds);\n  }\n\n  // For node < 7.6 you can use plain promises.\n  function PUT(req, res) {\n    return worldsService.getWorlds(req.query.worldName)\n      .then(function(worlds) {\n        if (!worlds.length) {\n          throw {\n            status: 404,\n            message: 'No worlds were found',\n          };\n        }\n        res.status(200).json(worlds);\n      });\n  }\n\n  /* apidocs removed for brevity's sake in this example. */\n\n  return operations;\n}\n```\n\n#### args.routesGlob\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|String|N|`**/*.js`|Allows different file extensions.|\n\n#### args.routesIndexFileRegExp\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|RegExp|N|`/(?:index)?\\.js$/`|Allows index files to be named differently.|\n\n#### args.securityFilter\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Function|N|null|Request handler for the api doc route.|\n\n`req.apiDoc` will be set to a copy of the generated api doc and the securityFilter is\nfree to modify it.  This is useful if you're implementing [Security Filtering](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#security-filtering).\n\n**Note:** You must end the request inside the filter.\n\n```js\ninitialize({\n  /* ... */\n  promiseMode: true,\n  securityFilter: async (req, res) => {\n    // do something, use await, whatever\n    if (!req.user) {\n      // only show paths to logged in users.\n      req.apiDoc.paths = {};\n    }\n    res.status(200).json(req.apiDoc);\n  }\n});\n```\n\n#### args.securityHandlers\n\n|Type|Required|Default Value|Description|\n|----|--------|-------------|-----------|\n|Object|N|null|Map name of security scheme name to a handler function.|\n\nIf you'd like to support security, define your schemes in your apiDoc like so:\n\n```javascript\nvar apiDoc = {\n  swagger: 2.0,\n  /* ... */\n  securityDefinitions: {\n    keyScheme: {\n      type: 'apiKey',\n      name: 'api_key',\n      in: 'header'\n    },\n    passwordScheme: {\n      type: 'basic'\n    }\n  }\n};\n```\n\nNext you can define your security handlers in the OpenAPI initialization args:\n\n```javascript\ninitialize({\n  apiDoc: apiDoc,\n  app: app,\n  securityHandlers: {\n    keyScheme: function(req, scopes, definition) {\n      /* do something.  You can assign values to req to make them available in\n      operation handlers. */\n      return Promise.resolve(true);\n    },\n    passwordScheme: function(req, scopes, definition) {\n      /* do something */\n      throw {\n        status: 401,\n        challenge: 'Basic realm=foo',\n        message: 'You must authenticate to access foo.'\n      };\n    }\n  }\n});\n```\n\nNow you can use `security` in your operation docs, or in the api doc.\n\n```javascript\nmodule.exports = {\n  post: post\n};\n\nfunction post(req, res, next) {\n  /* code */\n}\n\npost.apiDoc = {\n  /* ... */\n  security: [\n    {\n      passwordScheme: []\n    },\n    // if the previous set of security schemes fail, we move to the next block.\n    {\n      keyScheme: []\n    }\n  ]\n};\n```\n\nSee [openapi-security-handler](https://github.com/kogosoftwarellc/open-api/tree/master/packages/openapi-security-handler)\nfor more details.\n\nAlso see the sample usage in https://github.com/kogosoftwarellc/open-api/blob/master/packages/express-openapi/test/sample-projects/with-securityHandlers/app.js\n\n#### args.validateApiDoc\n\n|Type|Required|Default Value|Description|\n|----|--------|-----------|-------|\n|Boolean|N|true|Validates `args.apiDoc` before and after path population.  This does not effect individual route validation of route parameters.  You can disable this behavior by passing `false`.|\n\n## Using with TypeScript\n\nThis package includes definitions for TypeScript.\n\n### Prerequisites\n\nInstall definitions for `express` and `body-parser`(optional) via\n[typings](https://www.npmjs.com/package/typings).\n\n### TypeScript Example\n\nIn server script:\n```typescript\nimport * as express from \"express\";\nimport * as bodyParser from \"body-parser\";\nimport { initialize } from \"express-openapi\";\n\nconst app = express();\n\napp.use(bodyParser.json());\n\ninitialize({\n    apiDoc: './api-doc.js',\n    app,\n    paths: './built/api-paths'\n});\n\napp.use(<express.ErrorRequestHandler>(err, req, res, next) => {\n    res.status(err.status).json(err);\n});\n\napp.listen(3000);\n```\n\nIn route handler file like `<project>/src/api-paths/users/{id}.ts`:\n```typescript\n\nimport { Operation } from \"express-openapi\";\n\nexport const parameters = [\n  {\n    in: 'path',\n    name: 'id',\n    required: true,\n    type: 'integer'\n  }\n ];\n\nexport const GET: Operation = [\n    /* business middleware not expressible by OpenAPI documentation goes here */\n    (req, res, next) => {\n        res.status(200).json(/* return the user */);\n    }\n];\n\nGET.apiDoc = {\n  description: 'A description for retrieving a user.',\n  tags: ['users'],\n  operationId: 'getUser',\n  // parameters for this operation\n  parameters: [\n    {\n      in: 'query',\n      name: 'firstName',\n      type: 'string'\n    }\n  ],\n  responses: {\n    default: {\n      $ref: '#/definitions/Error'\n    }\n  }\n};\n\nexport const POST: Operation = (req, res, next) => {\n    /* ... */\n}\n\nPOST.apiDoc = {\n    /* ... */\n};\n```\n\n## Supported Versions of Node\n\n* `node@<=0.12.x` => `express-openapi@<=1.3.x`\n* `node@>0.12.x` => `express-openapi@*`\n\n## LICENSE\n``````\nThe MIT License (MIT)\n\nCopyright (c) 2016 Kogo Software LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n``````\n\n[downloads-image]: http://img.shields.io/npm/dm/express-openapi.svg\n[npm-url]: https://npmjs.org/package/express-openapi\n[npm-image]: http://img.shields.io/npm/v/express-openapi.svg\n\n[travis-url]: https://travis-ci.org/kogosoftwarellc/open-api\n[travis-image]: https://api.travis-ci.org/kogosoftwarellc/open-api.svg?branch=master\n\n[coveralls-url]: https://coveralls.io/r/kogosoftwarellc/open-api\n[coveralls-image]: https://coveralls.io/repos/github/kogosoftwarellc/open-api/badge.svg?branch=master\n\n[gitter-url]: https://gitter.im/kogosoftwarellc/open-api\n[gitter-image]: https://badges.gitter.im/kogosoftwarellc/open-api.png\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "https://github.com/kogosoftwarellc/open-api/tree/master/packages/express-openapi"
  },
  "scripts": {
    "cover": "nyc",
    "prepare": "tsc",
    "test": "mocha",
    "test-watch": "tsc && mocha --watch-extensions ts -w",
    "travis-test": "npm run cover"
  },
  "types": "./dist/index.d.ts",
  "version": "4.5.0"
}
